
TopLevel
    = _ Statement _
    ;

_
    = [ \t\n\r]*
    ;

Statement
    = SelectStatement
    ;

SelectStatement
    = SELECT { @Expression @FromClause? @WhereClause? #select }
    ;

WhereClause
    = WHERE { @Expression #where } _
    ;

FromClause
    = FROM { @Path #from } _
    ;

SELECT
    = 'select' !NCHAR _
    ;

WHERE
    = 'where' !NCHAR _
    ;

FROM
    = 'from' !NCHAR _
    ;

Path
    = AbsolutePath / RelativePath
    ;

RelativePath
    = { @PathSeg (DELIM @AbbrevatedPathSeg)* #path } _
    ;

AbsolutePath
    = { @RootPathSeg ( @AbbrevatedPathSeg (DELIM @AbbrevatedPathSeg)*)? #path } _
    ;

AbbrevatedPathSeg
    = @DecendantPathSeg? @PathSeg
    ;

PathSeg
    = { @PathName @Index? #tag }
    ;

RootPathSeg
    = { @RootPathName #tag }
    ;

DecendantPathSeg
    = { @DecendantPathName #tag }
    ;

PathName
    = { (WILDCARD / TAG) #name }
    ;

RootPathName
    = { DELIM `/root`#name }
    ;

DecendantPathName
    = { DELIM `/decendant`#name }
    ;

Index
    = '[' _ (Range / NumberList) _ ']' _
    ;

Range
    = { @Number _ '..' _ @Number #range }
    ;

NumberList
    = { (@Number (COMMA @Number)*)? #indexlist } _
    ;

WILDCARD
    = '*'
    ;

DELIM
    = '/'
    ;

TAG
    = '#'? SYMBOL
    ;

SYMBOL
    = [a-zA-Z_][a-zA-Z0-9_]*
    ;

PrimaryExpression
    = ( Number / String / FuncCall / Path ) _
    / '(' _ Expression _ ')' _
    ;

FuncCall
    = { @SYMBOL _ '(' @ArgumentList ')' #call } _ 
    ;

ArgumentList
    = { (@Expression (COMMA @Expression)*)? #arguments } _
    ;

EQ
    = '==' _ #eq
    ;

NEQ
    = '!=' _ #neq
    ;

LE
    = '<=' _ #le
    ;

GE
    = '>=' _ #ge
    ;

LT
    = '<' !'=' _ #lt
    ;

GT
    = '>' !'=' _ #gt
    ;

RATIONAL
    = EQ / NEQ / LE / GE / LT / GT
    ;

RelationalExpression
    = PrimaryExpression {@ RATIONAL @PrimaryExpression }*
    ;

OR
    = ('||' / 'or' !NCHAR) _ #or
    ;

AND
    = ('&&' / 'and' !NCHAR) _ #and
    ;

AndExpression
    = RelationalExpression {@ AND @RelationalExpression }*
    ;

OrExpression
    = AndExpression {@ OR @AndExpression }*
    ;

COMMA
    = ',' _
    ;

CommaExpression
    = OrExpression {@ COMMA @OrExpression }*
    ;

Expression
    = CommaExpression
    ;

NCHAR
    = [a-zA-Z0-9_]
    / [A-Z]
    / [0-9]
    / [_]
    ;

StringNoInterpolation
    = ( DQUOTE { @StringBodyDouble* #string } DQUOTE )
    / ( SQUOTE { @StringBodySingle* #string } SQUOTE )
    ;

String
    = StringDouble
    / StringSingle
    ;

StringDouble
    = DQUOTE { (@InterpolatedExpr / @StringBodyDouble)* #string } DQUOTE
    ;

StringSingle
    = SQUOTE { (@InterpolatedExpr / @StringBodySingle)* #string } SQUOTE
    ;

InterpolatedExpr
    = '${' Expression '}'
    ;

StringBodyDouble
    = { (!DQUOTE SCHAR)+ #segment }
    ;

StringBodySingle
    = { (!SQUOTE SCHAR)+ #segment }
    ;

SCHAR
    = ESCAPED / !'$' .
    ;

ESCAPED
    = '\\\\' `\\`/ '\\"' `"`/ '\\\'' `'` / '\\$'
    ;

DQUOTE
    = '"'
    ;

SQUOTE
    = '\"'
    ;

Number
    = { MINUS? INT FRAC? EXP? #number }
    ;

INT
    = ZERO / DIGIT1_9 DIGIT*
    ;

FRAC
    = POINT DIGIT+
    ;

POINT
    = '.'
    ;

EXP
    = E SIGN? DIGIT+
    ;

E
    = [eE]
    ;

SIGN
    = PLUS / MINUS
    ;

PLUS
    = '+'
    ;

MINUS
    = '-'
    ;

ZERO
    = '0'
    ;

DIGIT1_9
    = [1-9]
    ;

DIGIT
    = [0-9]
    ;
